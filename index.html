<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=980, initial-scale=1">
        <title>gen - a generics library for Go</title>
        <meta name="description" content="gen is a tool for adding generics-like functionality to Go, in the style of C#'s Linq or JavaScript's underscore.">
        <meta name="keywords" content="golang generics linq underscore">
        <meta name="viewport" content="width=device-width">
        <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css">
        <link rel="stylesheet" href="gen.css">
        <link rel="icon" type="image/png" href="gopher.png">
    </head>
    <body>
        <div id="sidebar">
            <nav>
                <h4><a href="#Concepts">Concepts</a></h4>
                <h4><a href="#Quick">Quick start</a></h4>
                <h4><a href="#Usage">Usage</a></h4>
                <h4><a href="#Methods">Standard Methods</a></h4>
                <p class="methods">
                    <a href="#Where">- Where</a>
                    <a href="#Count">- Count</a>
                    <a href="#Any">- Any</a>
                    <a href="#All">- All</a>
                    <a href="#First">- First</a>
                    <a href="#Single">- Single</a>
                    <a href="#Each">- Each</a>
                    <a href="#SortBy">- SortBy</a>
                    <a href="#Distinct">- Distinct</a>
                    <a href="#DistinctBy">- DistinctBy</a>
                    <a href="#MinBy">- MinBy</a>
                    <a href="#MaxBy">- MaxBy</a>
                </p>
                <h4><a href="#Projections">Projection Methods</a></h4>
                <p class="methods">
                    <a href="#Select">- Select</a>
                    <a href="#GroupBy">- GroupBy</a>
                    <a href="#Sum">- Sum</a>
                    <a href="#Average">- Average</a>
                    <a href="#MaxProjection">- Max</a>
                    <a href="#MinProjection">- Min</a>
                    <a href="#Aggregate">- Aggregate</a>
                </p>

                <h4><a href="#Subsetting">Subsetting</a></h4>
                <h4><a href="#Tips">Tips</a></h4>
                <h4><a href="#FAQ">FAQ</a></h4>
                <h4><a href="#Changelog">Changelog</a></h4>

                <br />

                <h4><a href="#Custom" class="strike">Custom Methods</a></h4><br />

            </nav>
        </div>
        <div id="content">
            <div id="right">
                <p><a href="https://github.com/DisposaBoy/GoSublime"><img src="completion.png" id="completion"></a></p>
                <p><a href="https://github.com/clipperhouse/gen" id="github">Source</a>&nbsp;</p>
                <p><a href="https://twitter.com/clipperhouse" id="twitter">@clipperhouse</a>&nbsp;</p>
            </div>
            <h1>gen <span class="alpha">alpha</span></h1>
            <h3>
                A library for bringing generics-like functionality to Go
            </h3>
            <p>
                gen is an attempt to bring some generics-like functionality to Go, with inspiration from C#’s <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable_methods(v=vs.110).aspx">Linq</a>, JavaScript’s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Methods">Array methods</a> and the <a href="http://underscorejs.org/">underscore</a> library. Operations include filtering, grouping, sorting and more.
            </p>

            <p>The pattern is to pass func’s as you would pass lambdas in Linq or functions in JavaScript.</p>

            <h2 id="Concepts">Concepts</h2>
            <p>gen generates code for your types, at development time, using the <strong>command line</strong>. gen is not an import; the generated source becomes part of your project and takes no external dependencies.</p>

            <p>You specify which of your types you’d like to generate <a href="#Methods">methods</a> on by marking them up with <strong>tags</strong>.</p>

            <p>A new slice type is generated for the types you specify. We call it the <strong>plural type</strong>. For example, if you gen an existing type Thing, a new plural type will be created:</p>

<pre>
type Things []Thing
</pre>

            <p>…and you’ll use this wherever you would otherwise use a slice.</p>

<pre>
myThings := Things{...}
otherThings := myThings.Where(func).Sort(func)
</pre>
            <h2 id="Quick">Quick start</h2>
            <p>Of course, start by installing Go, <a href="http://golang.org/doc/code.html">setting up paths</a>, etc. Then:</p>

<pre>
go get github.com/clipperhouse/gen
</pre>
            <p>Create a new Go project, and <code>cd</code> into it. Create a main.go file and define a type in it.</p>

            <p>Now, mark it up with a simple <code>+gen</code> tag in an adjacent comment like so:</p>
<pre>
// +gen
type MyType struct {
    ...
}
</pre>
            <p>And at the command line, simply type</p>
<pre>
gen
</pre>

            <p>You should see a new file, named <code>mytype_gen.go</code>. Have a look around. Try out that plural type.</p>

            <h2 id="Usage">Usage</h2>

            <p>If you’d like to generate methods that take pointers instead of value types, add the <code>*</code> directive.</p>
<pre>
// +gen *
type MyType struct {
    ...
}
</pre>
            <p>To select only a <a href="#Subsetting">subset</a> of methods, use:</p>
<pre>
// +gen * methods:"Any,Where,Count"
type MyType struct {
    ...
}
</pre>
            <p>(You’ll recognize this as the syntax of  <a href="http://golang.org/pkg/reflect/#StructTag">struct tags</a>.)</p>

            <p>To include <a href="#Projections">projection methods</a>, specify projected types:</p>
            
<pre>
// +gen * projections:"int,OtherType"
type MyType struct {
    ...
}
</pre>

            <h2 id="Methods">Methods</h2>

            <h4>Signatures use the example type *Thing.</h4>

            <h3 id="Where">Where</h3>
            <p>
                Returns a new slice (plural type) whose elements return true for passed func. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb534803(v=vs.110).aspx">Where</a> and JavaScript’s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">filter</a>.
            </p>
<pre>
func (rcv Things) Where(fn func(*Thing) bool) Things
</pre>
            <p>Example:</p>

<pre>
shiny := func(p *Product) bool {
    return p.Manufacturer == "Apple"
}
wishlist := products.Where(shiny)
</pre>

            <h3 id="Count">Count</h3>
            <p>
                Returns an int representing the number of elements which return true for passed func. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb535181(v=vs.110).aspx">Count</a>.
            </p>
<pre>
func (rcv Things) Count(fn func(*Thing) bool) int
</pre>
            <p>Example:</p>

<pre>
countDracula := monsters.Count(func(m *Monster) bool {
    return m.HasFangs()
})
</pre>

            <h3 id="Any">Any</h3>
            <p>
                Returns true if one or more elements returns true for passed func. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb534972(v=vs.110).aspx">Any</a> or underscore’s <a href="http://underscorejs.org/#some">some</a>.
            </p>
<pre>
func (rcv Things) Any(fn func(*Thing) bool) bool
</pre>
            <p>Example:</p>

<pre>
bueller := func(s *Student) bool {
    return s.IsTruant
}
willBeHijinks := students.Any(bueller)
</pre>

            <h3 id="All">All</h3>
            <p>
                Returns true if every element returns true for passed func. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb548541(v=vs.110).aspx">All</a> or underscore’s <a href="http://underscorejs.org/#every">every</a>.
            </p>
<pre>
func (rcv Things) All(fn func(*Thing) bool) bool
</pre>
            <p>Example:</p>

<pre>
mustPass := func(t *Thing) bool {
    return !t.IsEternal
}
cliché := things.All(mustPass)
</pre>

            <h3 id="First">First</h3>
            <p>
                Returns first element which returns true for passed func. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb535050(v=vs.110).aspx">First</a> or underscore’s <a href="http://underscorejs.org/#find">find</a>.
            </p>
<pre>
func (rcv Things) First(fn func(*Thing) bool) (*Thing, error)
</pre>
            <p>Example:</p>

<pre>
come := func(c *Customer) bool {
    return c.IsHere
}
served, err := people.First(come)
</pre>
            <p>Returns error if no elements satisfy the func.</p>

            <h3 id="Single">Single</h3>
            <p>
                Returns unique element which returns true for passed func. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb535118(v=vs.110).aspx">Single</a>.
            </p>
<pre>
func (rcv Things) Single(fn func(*Thing) bool) (*Thing, error)
</pre>
            <p>Example:</p>

<pre>
id := request.Id
byId := func(t *Thing) bool {
    return t.Id == id
}
item, err := things.Single(byId)
</pre>
            <p>Returns error if multiple or no elements satisfy the func.</p>

            <h3 id="Each">Each</h3>
            <p>
                Invokes passed func on every element. Comparable to underscore’s <a href="http://underscorejs.org/#each">each</a>.
            </p>
<pre>
func (rcv Things) Each(fn func(*Thing))
</pre>
            <p>Example:</p>

<pre>
update := func(s *Score) {
    s.Recalc()
}
scores.Each(update)
</pre>

            <h3 id="SortBy">SortBy</h3>
            <p>
                Returns a new slice (plural type) whose elements are sorted based on a func defining ‘less’. The less func takes two elements, and returns true if the first element is less than the second element. 
            </p>
<pre>
func (rcv Things) SortBy(less func(*Thing, *Thing) bool) Things
</pre>
            <p>Example:</p>

<pre>
rank := func(a, b *Player) bool {
    return a.Rank &lt; b.Rank
}
leaderboard := player.SortBy(rank)
</pre>

            <p><strong>SortByDesc</strong> works similarly, returning the elements in reverse order. Its implementation negates ‘less’, so is effectively Sort(equalOrGreater).</p>

            <p><strong>IsSortedBy(Desc)</strong> uses a similar idiom, returning true if the elements are sorted according to the ‘less’ comparer.</p>

            <h3 id="Distinct">Distinct</h3>
            <p>
                Returns a new slice (plural type) representing unique elements. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.distinct(v=vs.110).aspx">Distinct</a> or underscore’s <a href="http://underscorejs.org/#uniq">uniq</a>.
            </p>
<pre>
func (rcv Things) Distinct() Things
</pre>
            <p>Example:</p>

<pre>
snowflakes := hipsters.Distinct()
</pre>


            <p><strong>Note:</strong> Distinct will only be generated for types that support <a href="http://golang.org/doc/go1#equality">equality</a>.</p>

            <p>Keep in mind that pointers and values have different notions of equality, and therefore distinctness.</p>

            <h3 id="DistinctBy">DistinctBy</h3>
            <p>
                Returns a new slice (plural type) representing unique elements, where equality is defined by a passed func.
            </p>
<pre>
func (rcv Things) DistinctBy(func(*Thing, *Thing) bool) Things
</pre>
            <p>Example:</p>

<pre>
hairstyle := func(a *Fashionista, b *Fashionista) bool {
    a.Hairstyle == b.Hairstyle
}
trendsetters := fashionistas.DistinctBy(hairstyle)</pre>

            <h3 id="MinBy">MinBy</h3>
<pre>
func (rcv Things) MinBy(less func(*Thing, *Thing) bool) (*Thing, error)
</pre>
            <p>Returns the element containing the minimum value, when compared to other elements using a passed func defining ‘less’. Returns an error when invoked on an empty slice, considered an invalid operation.</p>

<p>Example:</p>

<pre>
price := func(a, b *Product) bool {
    return a.Price &lt; b.Price
}
cheapest, err := products.MinBy(price)
</pre>

            <p>In the case of multiple items being equally minimal, the first such element is returned.</p>

            <h3 id="MaxBy">MaxBy</h3>
<pre>
func (rcv Things) MaxBy(less func(*Thing, *Thing) bool) (*Thing, error)
</pre>
            <p>Returns the element containing the maximum value, when compared to other elements using a passed func defining ‘less’. Returns an error when invoked on an empty slice, considered an invalid operation.</p>

<p>Example:</p>

<pre>
area := func(a, b *House) bool {
    return a.Area() &lt; b.Area()
}
roomiest, err := houses.MaxBy(area)
</pre>

            <h2 id="Projections">Projections</h2>

            <h4>Projections allow ad-hoc mapping of one type to another.</h4>

            <p>Projections are specified by listing types in a <code>projection</code> tag. Here’s a marked-up type and some handy func’s, used in the examples below:</p>
<pre>
+gen projections:"int,string"
type Thing struct { 
    Department string
    Year       int
    Sales      float64
    ...
}

getYear := func(t *Thing) int {
    return t.Year
}

getSales := func(t *Thing) float64 {
    return t.Sales
}
</pre>
            <h3 id="Select">Select</h3>

            <p>Returns a projected slice given a func which maps Thing to {{Type}}. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb548891(v=vs.110).aspx">Select</a> or underscore’s <a href="http://underscorejs.org/#map">map</a>.</p>

<p>Example:</p>

<pre>
names := myThings.SelectString(func(t *Thing) string {
    return t.Department
})
// => ["Widgets", "Doodads"]
</pre>

            <h3 id="GroupBy">GroupBy</h3>

            <p>Groups elements into a map keyed by {{Type}}. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb534501(v=vs.110).aspx">GroupBy</a> or underscore’s <a href="http://underscorejs.org/#groupBy">groupBy</a>.</p>

<p>Example:</p>

<pre>
report := myThings.GroupByInt(getYear)
// => { "1995": [Thing1, Thing2], "2008": [Thing3, Thing4] }
</pre>

            <p><strong>Note:</strong> Because map keys must be compared for equality, GroupBy() will only be generated for types that support <a href="http://golang.org/doc/go1#equality">equality</a>.</p>

            <h3 id="Sum">Sum</h3>

            <p>Sums over all elements. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb298381(v=vs.110).aspx">Sum</a>.</p>

<p>Example:</p>

<pre>
revenue := myThings.SumFloat64(getSales)
// => 9457846.74
</pre>
            <p><strong>Note:</strong> Sum will only be generated for <a href="http://godoc.org/code.google.com/p/go.tools/go/types#BasicInfo">numeric types</a>.</p>

            <h3 id="Average">Average</h3>

            <p>Sums over all elements and divides by len(Things). Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb358946(v=vs.110).aspx">Average</a>.</p>

<p>Example:</p>

<pre>
avg := myThings.AverageFloat64(getSales)
// => 30005.74
</pre>
            <p><strong>Note:</strong> Average will only be generated for <a href="http://godoc.org/code.google.com/p/go.tools/go/types#BasicInfo">numeric types</a>.</p>

            <h3 id="MaxProjection">Max</h3>

            <p>Selects the largest projected value. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb534962(v=vs.110).aspx">Max</a>.</p>

<p>Example:</p>

<pre>
bigmoney := myThings.MaxFloat64(getSales)
// => 68598.99
</pre>

            <p><strong>Note:</strong> Max will only be generated for <a href="http://godoc.org/code.google.com/p/go.tools/go/types#BasicInfo">ordered types</a>, that is, types which can be evaluated as greater or less.</p>

            <h3 id="MinProjection">Min</h3>

            <p>Selects the least projected value. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb548741(v=vs.110).aspx">Min</a>.</p>

<p>Example:</p>

<pre>
earliest := myThings.MinInt(getYear)
// => 1995
</pre>
            <p><strong>Note:</strong> Min will only be generated for <a href="http://godoc.org/code.google.com/p/go.tools/go/types#BasicInfo">ordered types</a>, that is, types which can be evaluated as greater or less.</p>

            <h3 id="Aggregate">Aggregate</h3>

            <p>Iterates over Things, operating on each element while maintaining ‘state’. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb548651(v=vs.110).aspx">Aggregate</a> or underscore’s <a href="http://underscorejs.org/#reduce">reduce</a>.</p>

<p>Example:</p>

<pre>
var join = func(state string, value Thing) string {
    if state != "" {
        state += ", "
    }
    return state + value.Department
}
list := myThings.AggregateString(join)
// => "Sales, Marketing, Finance"
</pre>

            <h2 id="Subsetting">Subsetting</h2>

            <p>By default, all of the above <a href="#Methods">standard methods</a> are created when you <code>gen</code> a type. Similarly, all of the above <a href="#Projections">projection methods</a> are generated when you include a <code>projections</code> tag.</p>

            <p>If you would prefer only to generate specific methods, you can do so with a <code>methods</code> tag.</p>

<pre>
// +gen methods:"Count,Where,Select,GroupBy" projections:"string,float64"
type Thing struct {
    Name  string
    Year  int  
    Sales float64
}
</pre>

            <h2 id="Tips">Tips</h2>

            <h4>Start with buildable code</h4>
            <p>gen parses your source and evaluates types. If your code doesn’t parse or build, gen’s ability to reason about it is nearly zero. It will return errors at the command line.</p>

            <h4>-force</h4>
            <p>If you find yourself getting errors that you can’t resolve, you can use <code>gen -force</code> at the command line. gen will do its best with limited information, but your warranty is voided. The official party line is that this is undefined behavior.</p>

            <h2 id="FAQ">FAQ</h2>

            <h4>Why?</h4>
            <p>Go doesn't (yet) offer generic types, and we are accustomed to many of their use cases. Perhaps you are similarly accustomed, or would find them useful.</p>

            <h4>Code generation, really?</h4>
            <p>Yes. We do it to ensure compile-time safety, and to minimize magic. It’s just code, and you can read it.</p>
            <p>Codegen is not without its risks, we understand. But keep in mind that languages which do support generics are in fact doing <a href="http://msdn.microsoft.com/en-us/library/vstudio/f4a6ta2h(v=vs.110).aspx">something like code generation</a>, so perhaps gen’s approach is not that far out.</p>

            <h4>What’s that <a href="#Concepts">plural type</a> business?</h4>
            <p>gen creates a new slice type for your selected struct(s) because method receivers cannot be slices. It’s clearer and less verbose to type myThings.Where(fn) than package.Where(myThings, fn). Not to mention, the latter wouldn’t work for multiple struct types in the same package.</p>

            <h4>gen returns a new slice for many operations</h4>
            <p>This is by design, so that there is no question about whether you are mutating a slice in place or not. (An example would be Go’s builtin sort package, which works in-place.)</p>

            <p>Slices are <a href="http://blog.golang.org/go-slices-usage-and-internals">cheap</a>. You can reduce potential allocations by operating on pointer types, as well, by <a href="#Usage">using</a> the <code>*</code> directive in your gen tag.</p>

            <h4>You re-implemented sort?</h4>
            <p>Yes. Go’s <a href="http://godoc.org/sort">sort package</a> requires the fulfillment of three <a href="http://golang.org/pkg/sort/#Interface">interface members</a>, two of which are usually boilerplate. If you want to sort by different criteria, you need to implement multiple ‘alias’ types.</p>
            <p>gen’s <a href="#Sort">Sort</a> requires a single argument defining ‘less’, and no interface implementation. You can call ad-hoc sorts simply by passing a different func.</p>
            <p>gen’s implementation is a strongly-typed port of Go’s <a href="http://golang.org/src/pkg/sort/sort.go">implementation</a>. Performance characteristics should be similar.</p>
            <p>(There is an <a href="https://github.com/clipperhouse/gen/issues/25">open issue</a> to use the builtin sort package for primitive types where possible, which will limit the need for above.)</p>

            <h4>Could some of this be achieved using reflection or interfaces + type assertions?</h4>
            <p>Perhaps! It’s early days and the focus is on the API and compile-time safety. We’ve no doubt that more idiomatic approaches will reveal themselves.</p>

            <h4>Not all projection methods are generated for every type.</h4>
            <p>gen only generates methods that are meningful for a type. It won’t generate an average of strings, for example, and it won’t key a map with any type that doesn’t support equality.</p>

            <h4>What about imported types?</h4>
            <p>gen doesn’t support imported types, not least because one can’t define methods on them. You might instead create a local ‘alias’ type, something like:</p>

<pre>
type MyType otherPackage.Type

// or...

type MyType struct {
    otherPackage.Type
}
</pre>

            <h4>Why didn’t you implement X method?</h4>
            <p>Most likely:</p>
            <ul>
                <li>We haven’t gotten to it yet, or</li>
                <li>We haven’t found an idiomatic way to do it, or</li>
                <li>It doesn’t save you any code, or</li>
                <li>It duplicates something that Go does well.</li>
            </ul>

            <p>Here are some <a href="https://github.com/clipperhouse/gen#design-principles-for-contributors">design criteria</a>.</p>

            <h4>Can I use it?</h4>
            <p>We’d be thrilled if you would test it out and offer feedback. It’s still early bits, caveat emptor for production use. The API will likely be volatile prior to 1.0.</p>

            <p>Please let us know what you think via <a href="https://github.com/clipperhouse/gen/issues">GitHub issues</a> or ping Matt on Twitter <a href="https://twitter.com/clipperhouse">@clipperhouse</a>.</p>

            <h4>Can I help?</h4>
            <p>Sure, the code is <a href="https://github.com/clipperhouse/gen">here</a>.</p>

            <h4>Who is ‘we’?</h4>
            <p>Matt Sherman, mostly. You can reach him @clipperhouse on <a href="https://github.com/clipperhouse">GitHub</a> or <a href="https://twitter.com/clipperhouse">Twitter</a>. We have are ramping up with <a href="https://github.com/clipperhouse/gen/graphs/contributors">contributors</a> too.</p>

            <h2 id="Changelog">Changelog</h2>

            <p><strong>26 Jan 2014</strong></p>

            <p>This release includes breaking changes.</p>

            <p>Command-line type specification has been deprecated, and replaced by markup per <a href="https://github.com/clipperhouse/gen/issues/23">#23</a>. It takes the form of:</p>

<pre>// +gen
type MyType struct {...}
</pre>

            <p>Where before the command-line would be <code>gen package.Type</code>, now it's simply <code>gen</code>, which will locate and process your marked-up types.</p>

            <p>Here's a larger example:</p>

<pre>// +gen * methods:"Count,Where" projections:"SomeType,int"
type MyType struct {...}
</pre>

            <ul>
                <li>The <code>*</code> is a directive to generate methods which take a pointer type instead of a value type. Optional but recommended.</li>
                <li>The <code>methods</code> tag is for <a href="http://clipperhouse.github.io/gen/#Subsetting">subsetting</a> methods; replaces <code>gen:"..."</code>. Optional; omit it to generate all standard methods.</li>
                <li>The <code>projections</code> tag specifies types to be <a href="http://clipperhouse.github.io/gen/#Projections">projected</a> for methods such as <code>Select</code> and <code>GroupBy</code>. Optional. If the <code>methods</code> tag is omitted, all projection methods will be generated, appropriate to each type. (For example, Average will not be generated for non-numeric types.) You can subset projection methods using the <code>methods</code> tag above.</li>
            </ul><p>The <code>-all</code> flag has been deprecated, it's no longer a valid use case, given the above. The <code>-exported</code> flag, which is a modifier of same, is gone too.</p>

            <p>Custom methods, where specific member fields of a struct are marked up, have been deprecated. The <a href="https://github.com/clipperhouse/gen/issues/23">rationale</a> is that we prefer to project types, not fields.</p>

            <p><code>Sort(func)</code> has been renamed <code>SortBy(func)</code>, and similarly Max → MaxBy, Min → MinBy. This is done in anticipation of methods of those names which will <em>not</em> take a func, see <a href="https://github.com/clipperhouse/gen/issues/28">#28</a>.</p>


            <h2 id="Custom">Custom methods</h2>

            <p>...have been deprecated in favor of more-flexible <a href="#Projections">projections</a>. The rationale is <a href="https://github.com/clipperhouse/gen/issues/8">here</a>.</p>
</div>
</body>
</html>

