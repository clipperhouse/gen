package typewriter

import (
	"bytes"
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"strings"
	"text/template"
)

type app struct {
	// All typewriter.Type found in the current directory.
	Types []Type
	// All typewriter.TypeWriters registered on init.
	TypeWriters map[string]TypeWriter
}

// NewApp parses the current directory, collecting Types and their related information.
func NewApp(directive string) (app, error) {
	return NewAppFiltered(directive, nil)
}

// NewAppNewAppFiltered parses the current directory, collecting Types and their related information. Pass a filter to limit which files are operated on.
func NewAppFiltered(directive string, filter func(os.FileInfo) bool) (app, error) {
	var a app

	typs, err := getTypes(directive, filter)
	if err != nil {
		return a, err
	}

	a.Types = typs
	a.TypeWriters = typeWriters
	return a, nil
}

// Individual TypeWriters register on init, keyed by name
var typeWriters = make(map[string]TypeWriter)

// Register allows template packages to make themselves known to a 'parent' package, usually in the init() func.
// Comparable to the approach taken by builtin image package for registration of image types (eg image/png).
// Your program will do something like:
//	import (
//		"github.com/clipperhouse/typewriter"
//		_ "github.com/clipperhouse/typewriters/container"
//	)
func Register(tw TypeWriter) error {
	if _, exists := typeWriters[tw.Name()]; exists {
		return fmt.Errorf("A TypeWriter by the name %s has already been registered", tw.Name())
	}
	typeWriters[tw.Name()] = tw
	return nil
}

// WriteAll writes the generated code for all Types and TypeWriters in the App to respective files.
func (a app) WriteAll() {
	// TypeWriters which will write for each type; use string as key because Type is not comparable
	var writersByType = make(map[string][]TypeWriter)

	// validate them all (don't fail halfway)
	for _, t := range a.Types {
		for _, tw := range a.TypeWriters {
			write, err := tw.Validate(t)
			if err != nil {
				fmt.Println(err) // TODO: return error?
				return
			}
			if write {
				writersByType[t.String()] = append(writersByType[t.String()], tw)
			}
		}
	}

	// one buffer for each file, keyed by file name
	buffers := make(map[string]*bytes.Buffer)

	// write the generated code for each Type & TypeWriter into memory
	for _, t := range a.Types {
		for _, tw := range writersByType[t.String()] {
			var b bytes.Buffer
			write(&b, t, tw)
			f := strings.ToLower(fmt.Sprintf("%s_%s.go", t.LocalName(), tw.Name()))
			buffers[f] = &b
		}
	}

	// validate generated ast's before committing to files
	for f, b := range buffers {
		if _, err := parser.ParseFile(token.NewFileSet(), f, b.String(), 0); err != nil {
			fmt.Println(err) // TODO: return error?
			// TODO: prompt to write (ignored) _file on error? parsing errors are meaningless without.
			return
		}
	}

	// format and commit to files
	for f, b := range buffers {
		src, _ := formatToBytes(b) // error is ignored since ast is validated above
		writeFile(f, src)
	}
}

func write(w io.Writer, t Type, tw TypeWriter) {
	p := os.Args[0]
	caller := p[strings.LastIndex(p, "/")+1:]

	io.WriteString(w, fmt.Sprintf(`// This file was generated by %s, using the %s typewriter

`, caller, tw.Name()))
	tw.WriteHeader(w, t)
	// err on the side of extra line breaks; gofmt will tighten it up later
	w.Write([]byte(`

`))
	packageTmpl.Execute(w, t.Package.Name())
	importsTmpl.Execute(w, tw.Imports(t))
	tw.Write(w, t)
}

// gofmt
func formatToBytes(b *bytes.Buffer) ([]byte, error) {
	byts := b.Bytes()
	formatted, err := format.Source(byts)
	if err != nil {
		return byts, err
	}
	return formatted, nil
}

func writeFile(filename string, byts []byte) {
	w, err := os.Create(filename)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer w.Close()

	w.Write(byts)
}

var packageTmpl = template.Must(template.New("package").Parse(`package {{.}}
`))

var importsTmpl = template.Must(template.New("imports").Parse(`{{if gt (len .) 0}}
import ({{range .}}
	"{{.}}"{{end}}
)
{{end}}
`))
